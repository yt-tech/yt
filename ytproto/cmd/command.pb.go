// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd/command.proto

package command

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CommandType int32

const (
	CommandType_UNKNOWN                  CommandType = 0
	CommandType_ConnectRequest           CommandType = 1
	CommandType_ConnectResponse          CommandType = 2
	CommandType_SubscribeTopicRequest    CommandType = 3
	CommandType_SubscribeTopicResponse   CommandType = 4
	CommandType_UnsubscribeTopicRequest  CommandType = 5
	CommandType_UnsubscribeTopicResponse CommandType = 6
	CommandType_HoldMicRequest           CommandType = 7
	CommandType_HoldMIcResponse          CommandType = 8
	CommandType_ReleaseMicRequest        CommandType = 9
	CommandType_ReleaseMicResponse       CommandType = 10
	CommandType_DisconnectRequest        CommandType = 11
	CommandType_DisConnectResponse       CommandType = 12
)

var CommandType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "ConnectRequest",
	2:  "ConnectResponse",
	3:  "SubscribeTopicRequest",
	4:  "SubscribeTopicResponse",
	5:  "UnsubscribeTopicRequest",
	6:  "UnsubscribeTopicResponse",
	7:  "HoldMicRequest",
	8:  "HoldMIcResponse",
	9:  "ReleaseMicRequest",
	10: "ReleaseMicResponse",
	11: "DisconnectRequest",
	12: "DisConnectResponse",
}

var CommandType_value = map[string]int32{
	"UNKNOWN":                  0,
	"ConnectRequest":           1,
	"ConnectResponse":          2,
	"SubscribeTopicRequest":    3,
	"SubscribeTopicResponse":   4,
	"UnsubscribeTopicRequest":  5,
	"UnsubscribeTopicResponse": 6,
	"HoldMicRequest":           7,
	"HoldMIcResponse":          8,
	"ReleaseMicRequest":        9,
	"ReleaseMicResponse":       10,
	"DisconnectRequest":        11,
	"DisConnectResponse":       12,
}

func (x CommandType) String() string {
	return proto.EnumName(CommandType_name, int32(x))
}

func (CommandType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{0}
}

type BroadcastRegiste struct {
	Id                   int32    `protobuf:"zigzag32,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BroadcastRegiste) Reset()         { *m = BroadcastRegiste{} }
func (m *BroadcastRegiste) String() string { return proto.CompactTextString(m) }
func (*BroadcastRegiste) ProtoMessage()    {}
func (*BroadcastRegiste) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{0}
}
func (m *BroadcastRegiste) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastRegiste) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastRegiste.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastRegiste) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastRegiste.Merge(m, src)
}
func (m *BroadcastRegiste) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastRegiste) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastRegiste.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastRegiste proto.InternalMessageInfo

func (m *BroadcastRegiste) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Msg struct {
	Ctype                CommandType `protobuf:"varint,1,opt,name=ctype,proto3,enum=command.CommandType" json:"ctype,omitempty"`
	Request              *Request    `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	Response             *Response   `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
	AudioData            *AudioData  `protobuf:"bytes,4,opt,name=audioData,proto3" json:"audioData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{1}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetCtype() CommandType {
	if m != nil {
		return m.Ctype
	}
	return CommandType_UNKNOWN
}

func (m *Msg) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Msg) GetResponse() *Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Msg) GetAudioData() *AudioData {
	if m != nil {
		return m.AudioData
	}
	return nil
}

type AudioData struct {
	Id                   int32    `protobuf:"zigzag32,1,opt,name=id,proto3" json:"id,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AudioData) Reset()         { *m = AudioData{} }
func (m *AudioData) String() string { return proto.CompactTextString(m) }
func (*AudioData) ProtoMessage()    {}
func (*AudioData) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{2}
}
func (m *AudioData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudioData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AudioData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AudioData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioData.Merge(m, src)
}
func (m *AudioData) XXX_Size() int {
	return m.Size()
}
func (m *AudioData) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioData.DiscardUnknown(m)
}

var xxx_messageInfo_AudioData proto.InternalMessageInfo

func (m *AudioData) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AudioData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Request struct {
	Connect              *ConnectRequestInfo        `protobuf:"bytes,1,opt,name=connect,proto3" json:"connect,omitempty"`
	Subscribe            *SubscribeTopicRequestInfo `protobuf:"bytes,2,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{3}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetConnect() *ConnectRequestInfo {
	if m != nil {
		return m.Connect
	}
	return nil
}

func (m *Request) GetSubscribe() *SubscribeTopicRequestInfo {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

type Response struct {
	ConnectAck           *ConnectResponseInfo        `protobuf:"bytes,1,opt,name=connectAck,proto3" json:"connectAck,omitempty"`
	SubscribeAck         *SubscribeTopicResponseInfo `protobuf:"bytes,2,opt,name=subscribeAck,proto3" json:"subscribeAck,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{4}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetConnectAck() *ConnectResponseInfo {
	if m != nil {
		return m.ConnectAck
	}
	return nil
}

func (m *Response) GetSubscribeAck() *SubscribeTopicResponseInfo {
	if m != nil {
		return m.SubscribeAck
	}
	return nil
}

type ConnectRequestInfo struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectRequestInfo) Reset()         { *m = ConnectRequestInfo{} }
func (m *ConnectRequestInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectRequestInfo) ProtoMessage()    {}
func (*ConnectRequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{5}
}
func (m *ConnectRequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectRequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectRequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectRequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectRequestInfo.Merge(m, src)
}
func (m *ConnectRequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectRequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectRequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectRequestInfo proto.InternalMessageInfo

func (m *ConnectRequestInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ConnectResponseInfo struct {
	Result               int32    `protobuf:"zigzag32,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectResponseInfo) Reset()         { *m = ConnectResponseInfo{} }
func (m *ConnectResponseInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectResponseInfo) ProtoMessage()    {}
func (*ConnectResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{6}
}
func (m *ConnectResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectResponseInfo.Merge(m, src)
}
func (m *ConnectResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectResponseInfo proto.InternalMessageInfo

func (m *ConnectResponseInfo) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type SubscribeTopicRequestInfo struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Tid                  uint64   `protobuf:"varint,2,opt,name=tid,proto3" json:"tid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeTopicRequestInfo) Reset()         { *m = SubscribeTopicRequestInfo{} }
func (m *SubscribeTopicRequestInfo) String() string { return proto.CompactTextString(m) }
func (*SubscribeTopicRequestInfo) ProtoMessage()    {}
func (*SubscribeTopicRequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{7}
}
func (m *SubscribeTopicRequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeTopicRequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeTopicRequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeTopicRequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeTopicRequestInfo.Merge(m, src)
}
func (m *SubscribeTopicRequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeTopicRequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeTopicRequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeTopicRequestInfo proto.InternalMessageInfo

func (m *SubscribeTopicRequestInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SubscribeTopicRequestInfo) GetTid() uint64 {
	if m != nil {
		return m.Tid
	}
	return 0
}

type SubscribeTopicResponseInfo struct {
	Result               int32    `protobuf:"zigzag32,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeTopicResponseInfo) Reset()         { *m = SubscribeTopicResponseInfo{} }
func (m *SubscribeTopicResponseInfo) String() string { return proto.CompactTextString(m) }
func (*SubscribeTopicResponseInfo) ProtoMessage()    {}
func (*SubscribeTopicResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{8}
}
func (m *SubscribeTopicResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeTopicResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeTopicResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeTopicResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeTopicResponseInfo.Merge(m, src)
}
func (m *SubscribeTopicResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeTopicResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeTopicResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeTopicResponseInfo proto.InternalMessageInfo

func (m *SubscribeTopicResponseInfo) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type UnsubscribeTopicRequestInfo struct {
	Id                   int32    `protobuf:"zigzag32,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnsubscribeTopicRequestInfo) Reset()         { *m = UnsubscribeTopicRequestInfo{} }
func (m *UnsubscribeTopicRequestInfo) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeTopicRequestInfo) ProtoMessage()    {}
func (*UnsubscribeTopicRequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{9}
}
func (m *UnsubscribeTopicRequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeTopicRequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeTopicRequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeTopicRequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeTopicRequestInfo.Merge(m, src)
}
func (m *UnsubscribeTopicRequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeTopicRequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeTopicRequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeTopicRequestInfo proto.InternalMessageInfo

func (m *UnsubscribeTopicRequestInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UnsubscribeTopicRequestInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type UnsubscribeTopicResponseInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnsubscribeTopicResponseInfo) Reset()         { *m = UnsubscribeTopicResponseInfo{} }
func (m *UnsubscribeTopicResponseInfo) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeTopicResponseInfo) ProtoMessage()    {}
func (*UnsubscribeTopicResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{10}
}
func (m *UnsubscribeTopicResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeTopicResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeTopicResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeTopicResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeTopicResponseInfo.Merge(m, src)
}
func (m *UnsubscribeTopicResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeTopicResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeTopicResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeTopicResponseInfo proto.InternalMessageInfo

type HoldMicRequestInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HoldMicRequestInfo) Reset()         { *m = HoldMicRequestInfo{} }
func (m *HoldMicRequestInfo) String() string { return proto.CompactTextString(m) }
func (*HoldMicRequestInfo) ProtoMessage()    {}
func (*HoldMicRequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{11}
}
func (m *HoldMicRequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HoldMicRequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HoldMicRequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HoldMicRequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HoldMicRequestInfo.Merge(m, src)
}
func (m *HoldMicRequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *HoldMicRequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HoldMicRequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HoldMicRequestInfo proto.InternalMessageInfo

type HoldMIcResponseInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HoldMIcResponseInfo) Reset()         { *m = HoldMIcResponseInfo{} }
func (m *HoldMIcResponseInfo) String() string { return proto.CompactTextString(m) }
func (*HoldMIcResponseInfo) ProtoMessage()    {}
func (*HoldMIcResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{12}
}
func (m *HoldMIcResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HoldMIcResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HoldMIcResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HoldMIcResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HoldMIcResponseInfo.Merge(m, src)
}
func (m *HoldMIcResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *HoldMIcResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HoldMIcResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HoldMIcResponseInfo proto.InternalMessageInfo

type ReleaseMicRequestInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReleaseMicRequestInfo) Reset()         { *m = ReleaseMicRequestInfo{} }
func (m *ReleaseMicRequestInfo) String() string { return proto.CompactTextString(m) }
func (*ReleaseMicRequestInfo) ProtoMessage()    {}
func (*ReleaseMicRequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{13}
}
func (m *ReleaseMicRequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseMicRequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReleaseMicRequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReleaseMicRequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseMicRequestInfo.Merge(m, src)
}
func (m *ReleaseMicRequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseMicRequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseMicRequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseMicRequestInfo proto.InternalMessageInfo

type ReleaseMicResponseInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReleaseMicResponseInfo) Reset()         { *m = ReleaseMicResponseInfo{} }
func (m *ReleaseMicResponseInfo) String() string { return proto.CompactTextString(m) }
func (*ReleaseMicResponseInfo) ProtoMessage()    {}
func (*ReleaseMicResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{14}
}
func (m *ReleaseMicResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseMicResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReleaseMicResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReleaseMicResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseMicResponseInfo.Merge(m, src)
}
func (m *ReleaseMicResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseMicResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseMicResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseMicResponseInfo proto.InternalMessageInfo

type DisconnectRequstInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DisconnectRequstInfo) Reset()         { *m = DisconnectRequstInfo{} }
func (m *DisconnectRequstInfo) String() string { return proto.CompactTextString(m) }
func (*DisconnectRequstInfo) ProtoMessage()    {}
func (*DisconnectRequstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{15}
}
func (m *DisconnectRequstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisconnectRequstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisconnectRequstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisconnectRequstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisconnectRequstInfo.Merge(m, src)
}
func (m *DisconnectRequstInfo) XXX_Size() int {
	return m.Size()
}
func (m *DisconnectRequstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DisconnectRequstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DisconnectRequstInfo proto.InternalMessageInfo

type DisConnectResponseInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DisConnectResponseInfo) Reset()         { *m = DisConnectResponseInfo{} }
func (m *DisConnectResponseInfo) String() string { return proto.CompactTextString(m) }
func (*DisConnectResponseInfo) ProtoMessage()    {}
func (*DisConnectResponseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{16}
}
func (m *DisConnectResponseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisConnectResponseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisConnectResponseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisConnectResponseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisConnectResponseInfo.Merge(m, src)
}
func (m *DisConnectResponseInfo) XXX_Size() int {
	return m.Size()
}
func (m *DisConnectResponseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DisConnectResponseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DisConnectResponseInfo proto.InternalMessageInfo

type ManagerAck struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ManagerAck) Reset()         { *m = ManagerAck{} }
func (m *ManagerAck) String() string { return proto.CompactTextString(m) }
func (*ManagerAck) ProtoMessage()    {}
func (*ManagerAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{17}
}
func (m *ManagerAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManagerAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManagerAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManagerAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagerAck.Merge(m, src)
}
func (m *ManagerAck) XXX_Size() int {
	return m.Size()
}
func (m *ManagerAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagerAck.DiscardUnknown(m)
}

var xxx_messageInfo_ManagerAck proto.InternalMessageInfo

type BroadcastRegisteInfo struct {
	Id                   int32    `protobuf:"zigzag32,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BroadcastRegisteInfo) Reset()         { *m = BroadcastRegisteInfo{} }
func (m *BroadcastRegisteInfo) String() string { return proto.CompactTextString(m) }
func (*BroadcastRegisteInfo) ProtoMessage()    {}
func (*BroadcastRegisteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{18}
}
func (m *BroadcastRegisteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastRegisteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastRegisteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastRegisteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastRegisteInfo.Merge(m, src)
}
func (m *BroadcastRegisteInfo) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastRegisteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastRegisteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastRegisteInfo proto.InternalMessageInfo

func (m *BroadcastRegisteInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type BroadcastRegisteAckInfo struct {
	Id                   int32    `protobuf:"zigzag32,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BroadcastRegisteAckInfo) Reset()         { *m = BroadcastRegisteAckInfo{} }
func (m *BroadcastRegisteAckInfo) String() string { return proto.CompactTextString(m) }
func (*BroadcastRegisteAckInfo) ProtoMessage()    {}
func (*BroadcastRegisteAckInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bf3ce92cb0a9bc1, []int{19}
}
func (m *BroadcastRegisteAckInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastRegisteAckInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastRegisteAckInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastRegisteAckInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastRegisteAckInfo.Merge(m, src)
}
func (m *BroadcastRegisteAckInfo) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastRegisteAckInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastRegisteAckInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastRegisteAckInfo proto.InternalMessageInfo

func (m *BroadcastRegisteAckInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func init() {
	proto.RegisterEnum("command.CommandType", CommandType_name, CommandType_value)
	proto.RegisterType((*BroadcastRegiste)(nil), "command.BroadcastRegiste")
	proto.RegisterType((*Msg)(nil), "command.Msg")
	proto.RegisterType((*AudioData)(nil), "command.AudioData")
	proto.RegisterType((*Request)(nil), "command.Request")
	proto.RegisterType((*Response)(nil), "command.Response")
	proto.RegisterType((*ConnectRequestInfo)(nil), "command.ConnectRequestInfo")
	proto.RegisterType((*ConnectResponseInfo)(nil), "command.ConnectResponseInfo")
	proto.RegisterType((*SubscribeTopicRequestInfo)(nil), "command.SubscribeTopicRequestInfo")
	proto.RegisterType((*SubscribeTopicResponseInfo)(nil), "command.SubscribeTopicResponseInfo")
	proto.RegisterType((*UnsubscribeTopicRequestInfo)(nil), "command.UnsubscribeTopicRequestInfo")
	proto.RegisterType((*UnsubscribeTopicResponseInfo)(nil), "command.UnsubscribeTopicResponseInfo")
	proto.RegisterType((*HoldMicRequestInfo)(nil), "command.HoldMicRequestInfo")
	proto.RegisterType((*HoldMIcResponseInfo)(nil), "command.HoldMIcResponseInfo")
	proto.RegisterType((*ReleaseMicRequestInfo)(nil), "command.ReleaseMicRequestInfo")
	proto.RegisterType((*ReleaseMicResponseInfo)(nil), "command.ReleaseMicResponseInfo")
	proto.RegisterType((*DisconnectRequstInfo)(nil), "command.DisconnectRequstInfo")
	proto.RegisterType((*DisConnectResponseInfo)(nil), "command.DisConnectResponseInfo")
	proto.RegisterType((*ManagerAck)(nil), "command.ManagerAck")
	proto.RegisterType((*BroadcastRegisteInfo)(nil), "command.BroadcastRegisteInfo")
	proto.RegisterType((*BroadcastRegisteAckInfo)(nil), "command.BroadcastRegisteAckInfo")
}

func init() { proto.RegisterFile("cmd/command.proto", fileDescriptor_5bf3ce92cb0a9bc1) }

var fileDescriptor_5bf3ce92cb0a9bc1 = []byte{
	// 681 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0xe3, 0x24, 0xad, 0x9b, 0x49, 0x54, 0x36, 0xd3, 0x24, 0x4d, 0xd3, 0x12, 0x55, 0x8b,
	0x84, 0x4a, 0x51, 0x3f, 0x14, 0xe0, 0x06, 0x82, 0x94, 0x4a, 0x50, 0xa1, 0x14, 0x69, 0x69, 0xd5,
	0xb3, 0x63, 0x2f, 0x91, 0xd5, 0xc6, 0x0e, 0x5e, 0xe7, 0xd0, 0x23, 0xbc, 0x01, 0x37, 0x1e, 0x06,
	0x71, 0xe6, 0xc8, 0x23, 0xa0, 0xf0, 0x22, 0x68, 0xfd, 0x15, 0x7f, 0x56, 0x3d, 0x79, 0xbd, 0xf3,
	0x9b, 0xd9, 0x99, 0xf9, 0x8f, 0xd7, 0xd0, 0xd4, 0xa7, 0xc6, 0x91, 0x6e, 0x4f, 0xa7, 0x9a, 0x65,
	0x1c, 0xce, 0x1c, 0xdb, 0xb5, 0x51, 0x0d, 0x5e, 0x29, 0x05, 0x72, 0xe2, 0xd8, 0x9a, 0xa1, 0x6b,
	0xc2, 0x65, 0x7c, 0x62, 0x0a, 0x97, 0xe3, 0x3a, 0x94, 0x4d, 0xa3, 0xab, 0xec, 0x2a, 0x7b, 0x4d,
	0x56, 0x36, 0x0d, 0xfa, 0x4b, 0x81, 0xca, 0x48, 0x4c, 0x70, 0x1f, 0x56, 0x74, 0xf7, 0x76, 0xc6,
	0x3d, 0xd3, 0xfa, 0xa0, 0x75, 0x18, 0xc6, 0x7c, 0xeb, 0x3f, 0x2f, 0x6e, 0x67, 0x9c, 0xf9, 0x08,
	0xee, 0x83, 0xea, 0xf0, 0x2f, 0x73, 0x2e, 0xdc, 0x6e, 0x79, 0x57, 0xd9, 0xab, 0x0f, 0x48, 0x44,
	0x33, 0x7f, 0x9f, 0x85, 0x00, 0x1e, 0xc0, 0x9a, 0xc3, 0xc5, 0xcc, 0xb6, 0x04, 0xef, 0x56, 0x3c,
	0xb8, 0x19, 0x83, 0x7d, 0x03, 0x8b, 0x10, 0x3c, 0x86, 0x9a, 0x36, 0x37, 0x4c, 0xfb, 0x54, 0x73,
	0xb5, 0x6e, 0xd5, 0xe3, 0x31, 0xe2, 0x87, 0xa1, 0x85, 0x2d, 0x21, 0x7a, 0x04, 0xb5, 0x68, 0x3f,
	0x5d, 0x1d, 0x22, 0x54, 0x0d, 0x19, 0x49, 0xa6, 0xd9, 0x60, 0xde, 0x9a, 0x7e, 0x53, 0x40, 0x0d,
	0xd2, 0xc4, 0x17, 0xa0, 0xea, 0xb6, 0x65, 0x71, 0xdd, 0xf5, 0x9c, 0xea, 0x83, 0xed, 0x58, 0xdd,
	0xde, 0x7e, 0x40, 0x9e, 0x59, 0x9f, 0x6d, 0x16, 0xb2, 0xf8, 0x06, 0x6a, 0x62, 0x3e, 0x16, 0xba,
	0x63, 0x8e, 0x79, 0xd0, 0x02, 0x1a, 0x39, 0x7e, 0x0a, 0x2d, 0x17, 0xf6, 0xcc, 0xd4, 0xe3, 0xfe,
	0x4b, 0x27, 0xfa, 0x5d, 0x81, 0xb5, 0xb0, 0x7c, 0x7c, 0x09, 0x10, 0x44, 0x1e, 0xea, 0xd7, 0x41,
	0x22, 0x3b, 0xd9, 0x44, 0x7c, 0xda, 0x8b, 0x14, 0xe3, 0xf1, 0x1d, 0x34, 0xa2, 0xb8, 0xd2, 0xdf,
	0xcf, 0xe7, 0x51, 0x61, 0x3e, 0xb1, 0x30, 0x09, 0x47, 0xfa, 0x18, 0x30, 0x5b, 0x34, 0x12, 0xa8,
	0xcc, 0x83, 0x9e, 0x56, 0x99, 0x5c, 0xd2, 0x03, 0xd8, 0xc8, 0xc9, 0x09, 0x3b, 0xb0, 0xea, 0x70,
	0x31, 0xbf, 0x71, 0x83, 0xfe, 0x07, 0x6f, 0xf4, 0x35, 0x6c, 0x15, 0xb6, 0x24, 0x1b, 0x5d, 0xee,
	0xb8, 0xa6, 0xe1, 0x55, 0x51, 0x65, 0x72, 0x49, 0x9f, 0x43, 0xaf, 0xb8, 0x86, 0xc2, 0x63, 0x87,
	0xb0, 0x7d, 0x69, 0x89, 0xc2, 0x83, 0x73, 0x26, 0xc5, 0xd2, 0xa6, 0xbe, 0x9a, 0x35, 0xe6, 0xad,
	0x69, 0x1f, 0x76, 0xb2, 0x21, 0x96, 0x47, 0xd3, 0x16, 0xe0, 0x7b, 0xfb, 0xc6, 0x18, 0x25, 0x22,
	0xd3, 0x36, 0x6c, 0x78, 0xbb, 0x67, 0x49, 0x78, 0x13, 0xda, 0x8c, 0xdf, 0x70, 0x4d, 0xf0, 0x14,
	0xdf, 0x85, 0x4e, 0xdc, 0x10, 0x73, 0xe9, 0x40, 0xeb, 0xd4, 0x14, 0xfa, 0x52, 0x93, 0xa5, 0xc7,
	0xa9, 0x29, 0x72, 0x34, 0xa0, 0x0d, 0x80, 0x91, 0x66, 0x69, 0x13, 0xee, 0xf8, 0x82, 0xb6, 0xd2,
	0xdf, 0x7f, 0x5e, 0xed, 0xf4, 0x09, 0x6c, 0xa6, 0xb9, 0xa1, 0x7e, 0x9d, 0x87, 0xee, 0xff, 0x2c,
	0x43, 0x3d, 0x76, 0x23, 0x60, 0x1d, 0xd4, 0xcb, 0xf3, 0x0f, 0xe7, 0x1f, 0xaf, 0xce, 0x49, 0x09,
	0x11, 0xd6, 0x93, 0x03, 0x44, 0x14, 0xdc, 0x80, 0x07, 0xa9, 0x44, 0x49, 0x19, 0xb7, 0xa0, 0x9d,
	0x3b, 0x12, 0xa4, 0x82, 0x3d, 0xe8, 0xe4, 0x8b, 0x4d, 0xaa, 0xb8, 0x0d, 0x9b, 0x05, 0x92, 0x92,
	0x15, 0xdc, 0x81, 0x6e, 0x91, 0x58, 0x64, 0x55, 0xa6, 0x96, 0x94, 0x8a, 0xa8, 0x32, 0xb5, 0x94,
	0x50, 0x64, 0x0d, 0xdb, 0xd0, 0xcc, 0xc8, 0x44, 0x6a, 0xd8, 0x01, 0xcc, 0x8a, 0x44, 0x40, 0xe2,
	0x49, 0x89, 0x24, 0x5e, 0x97, 0x78, 0x56, 0x21, 0xd2, 0x18, 0x7c, 0xad, 0x80, 0x1a, 0x08, 0x84,
	0xa3, 0x74, 0xb7, 0xf0, 0xae, 0xcb, 0xa7, 0x77, 0xe7, 0x85, 0x40, 0x4b, 0x38, 0x2e, 0xe8, 0x29,
	0xde, 0xe3, 0x66, 0xea, 0xdd, 0xe7, 0xb6, 0xa0, 0x25, 0x7c, 0x95, 0xee, 0x62, 0x2c, 0xe5, 0xec,
	0x97, 0xd0, 0x6b, 0x44, 0xc6, 0x91, 0x98, 0xd0, 0x12, 0x3e, 0x85, 0x5a, 0x34, 0x67, 0x98, 0x30,
	0xa6, 0xd1, 0x63, 0x05, 0xaf, 0x72, 0x7e, 0x5e, 0x0f, 0x23, 0x2a, 0x6f, 0xae, 0x7b, 0xbb, 0x85,
	0xe6, 0x60, 0x9c, 0x65, 0xe0, 0x13, 0xf2, 0x7b, 0xd1, 0x57, 0xfe, 0x2c, 0xfa, 0xca, 0xdf, 0x45,
	0x5f, 0xf9, 0xf1, 0xaf, 0x5f, 0x1a, 0xaf, 0x7a, 0xff, 0xcd, 0x67, 0xff, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x0b, 0x00, 0x51, 0x0b, 0x4c, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ManagerClient is the client API for Manager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ManagerClient interface {
	ConnectRequest(ctx context.Context, in *ConnectRequestInfo, opts ...grpc.CallOption) (*ConnectResponseInfo, error)
	SubscribeTopicRequest(ctx context.Context, in *SubscribeTopicRequestInfo, opts ...grpc.CallOption) (*SubscribeTopicResponseInfo, error)
	// rpc UnsubscribeTopicRequest (UnsubscribeTopicRequestInfo) returns (ManagerAck) {}
	HoldMicRequest(ctx context.Context, in *HoldMicRequestInfo, opts ...grpc.CallOption) (*Msg, error)
	// rpc ReleaseMicRequest (ReleaseMicRequestInfo) returns (ManagerAck) {}
	Broadcast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (Manager_BroadcastClient, error)
	BroadcastRegiste(ctx context.Context, in *BroadcastRegisteInfo, opts ...grpc.CallOption) (Manager_BroadcastRegisteClient, error)
}

type managerClient struct {
	cc *grpc.ClientConn
}

func NewManagerClient(cc *grpc.ClientConn) ManagerClient {
	return &managerClient{cc}
}

func (c *managerClient) ConnectRequest(ctx context.Context, in *ConnectRequestInfo, opts ...grpc.CallOption) (*ConnectResponseInfo, error) {
	out := new(ConnectResponseInfo)
	err := c.cc.Invoke(ctx, "/command.Manager/ConnectRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) SubscribeTopicRequest(ctx context.Context, in *SubscribeTopicRequestInfo, opts ...grpc.CallOption) (*SubscribeTopicResponseInfo, error) {
	out := new(SubscribeTopicResponseInfo)
	err := c.cc.Invoke(ctx, "/command.Manager/SubscribeTopicRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) HoldMicRequest(ctx context.Context, in *HoldMicRequestInfo, opts ...grpc.CallOption) (*Msg, error) {
	out := new(Msg)
	err := c.cc.Invoke(ctx, "/command.Manager/HoldMicRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) Broadcast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (Manager_BroadcastClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Manager_serviceDesc.Streams[0], "/command.Manager/Broadcast", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerBroadcastClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Manager_BroadcastClient interface {
	Recv() (*Msg, error)
	grpc.ClientStream
}

type managerBroadcastClient struct {
	grpc.ClientStream
}

func (x *managerBroadcastClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerClient) BroadcastRegiste(ctx context.Context, in *BroadcastRegisteInfo, opts ...grpc.CallOption) (Manager_BroadcastRegisteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Manager_serviceDesc.Streams[1], "/command.Manager/BroadcastRegiste", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerBroadcastRegisteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Manager_BroadcastRegisteClient interface {
	Recv() (*BroadcastRegisteAckInfo, error)
	grpc.ClientStream
}

type managerBroadcastRegisteClient struct {
	grpc.ClientStream
}

func (x *managerBroadcastRegisteClient) Recv() (*BroadcastRegisteAckInfo, error) {
	m := new(BroadcastRegisteAckInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ManagerServer is the server API for Manager service.
type ManagerServer interface {
	ConnectRequest(context.Context, *ConnectRequestInfo) (*ConnectResponseInfo, error)
	SubscribeTopicRequest(context.Context, *SubscribeTopicRequestInfo) (*SubscribeTopicResponseInfo, error)
	// rpc UnsubscribeTopicRequest (UnsubscribeTopicRequestInfo) returns (ManagerAck) {}
	HoldMicRequest(context.Context, *HoldMicRequestInfo) (*Msg, error)
	// rpc ReleaseMicRequest (ReleaseMicRequestInfo) returns (ManagerAck) {}
	Broadcast(*Msg, Manager_BroadcastServer) error
	BroadcastRegiste(*BroadcastRegisteInfo, Manager_BroadcastRegisteServer) error
}

// UnimplementedManagerServer can be embedded to have forward compatible implementations.
type UnimplementedManagerServer struct {
}

func (*UnimplementedManagerServer) ConnectRequest(ctx context.Context, req *ConnectRequestInfo) (*ConnectResponseInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectRequest not implemented")
}
func (*UnimplementedManagerServer) SubscribeTopicRequest(ctx context.Context, req *SubscribeTopicRequestInfo) (*SubscribeTopicResponseInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeTopicRequest not implemented")
}
func (*UnimplementedManagerServer) HoldMicRequest(ctx context.Context, req *HoldMicRequestInfo) (*Msg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HoldMicRequest not implemented")
}
func (*UnimplementedManagerServer) Broadcast(req *Msg, srv Manager_BroadcastServer) error {
	return status.Errorf(codes.Unimplemented, "method Broadcast not implemented")
}
func (*UnimplementedManagerServer) BroadcastRegiste(req *BroadcastRegisteInfo, srv Manager_BroadcastRegisteServer) error {
	return status.Errorf(codes.Unimplemented, "method BroadcastRegiste not implemented")
}

func RegisterManagerServer(s *grpc.Server, srv ManagerServer) {
	s.RegisterService(&_Manager_serviceDesc, srv)
}

func _Manager_ConnectRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequestInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ConnectRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/command.Manager/ConnectRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ConnectRequest(ctx, req.(*ConnectRequestInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_SubscribeTopicRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeTopicRequestInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).SubscribeTopicRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/command.Manager/SubscribeTopicRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).SubscribeTopicRequest(ctx, req.(*SubscribeTopicRequestInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_HoldMicRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HoldMicRequestInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).HoldMicRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/command.Manager/HoldMicRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).HoldMicRequest(ctx, req.(*HoldMicRequestInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Msg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServer).Broadcast(m, &managerBroadcastServer{stream})
}

type Manager_BroadcastServer interface {
	Send(*Msg) error
	grpc.ServerStream
}

type managerBroadcastServer struct {
	grpc.ServerStream
}

func (x *managerBroadcastServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func _Manager_BroadcastRegiste_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BroadcastRegisteInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServer).BroadcastRegiste(m, &managerBroadcastRegisteServer{stream})
}

type Manager_BroadcastRegisteServer interface {
	Send(*BroadcastRegisteAckInfo) error
	grpc.ServerStream
}

type managerBroadcastRegisteServer struct {
	grpc.ServerStream
}

func (x *managerBroadcastRegisteServer) Send(m *BroadcastRegisteAckInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _Manager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "command.Manager",
	HandlerType: (*ManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConnectRequest",
			Handler:    _Manager_ConnectRequest_Handler,
		},
		{
			MethodName: "SubscribeTopicRequest",
			Handler:    _Manager_SubscribeTopicRequest_Handler,
		},
		{
			MethodName: "HoldMicRequest",
			Handler:    _Manager_HoldMicRequest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Broadcast",
			Handler:       _Manager_Broadcast_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BroadcastRegiste",
			Handler:       _Manager_BroadcastRegiste_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cmd/command.proto",
}

func (m *BroadcastRegiste) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastRegiste) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastRegiste) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Id)<<1)^uint32((m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AudioData != nil {
		{
			size, err := m.AudioData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ctype != 0 {
		i = encodeVarintCommand(dAtA, i, uint64(m.Ctype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AudioData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudioData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Id)<<1)^uint32((m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Subscribe != nil {
		{
			size, err := m.Subscribe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Connect != nil {
		{
			size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscribeAck != nil {
		{
			size, err := m.SubscribeAck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ConnectAck != nil {
		{
			size, err := m.ConnectAck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommand(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnectRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectRequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintCommand(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Result)<<1)^uint32((m.Result>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeTopicRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeTopicRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeTopicRequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tid != 0 {
		i = encodeVarintCommand(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintCommand(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeTopicResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeTopicResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeTopicResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Result)<<1)^uint32((m.Result>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsubscribeTopicRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeTopicRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeTopicRequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Id)<<1)^uint32((m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsubscribeTopicResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeTopicResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeTopicResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HoldMicRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HoldMicRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HoldMicRequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HoldMIcResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HoldMIcResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HoldMIcResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseMicRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseMicRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseMicRequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseMicResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseMicResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseMicResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DisconnectRequstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisconnectRequstInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisconnectRequstInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DisConnectResponseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisConnectResponseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisConnectResponseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ManagerAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManagerAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManagerAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastRegisteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastRegisteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastRegisteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Id)<<1)^uint32((m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastRegisteAckInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastRegisteAckInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastRegisteAckInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintCommand(dAtA, i, uint64((uint32(m.Id)<<1)^uint32((m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommand(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommand(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BroadcastRegiste) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sozCommand(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ctype != 0 {
		n += 1 + sovCommand(uint64(m.Ctype))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.AudioData != nil {
		l = m.AudioData.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AudioData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sozCommand(uint64(m.Id))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connect != nil {
		l = m.Connect.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Subscribe != nil {
		l = m.Subscribe.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectAck != nil {
		l = m.ConnectAck.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.SubscribeAck != nil {
		l = m.SubscribeAck.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectRequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCommand(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sozCommand(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeTopicRequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCommand(uint64(m.Uid))
	}
	if m.Tid != 0 {
		n += 1 + sovCommand(uint64(m.Tid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeTopicResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sozCommand(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnsubscribeTopicRequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sozCommand(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnsubscribeTopicResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HoldMicRequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HoldMIcResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReleaseMicRequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReleaseMicResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DisconnectRequstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DisConnectResponseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ManagerAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BroadcastRegisteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sozCommand(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BroadcastRegisteAckInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sozCommand(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCommand(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommand(x uint64) (n int) {
	return sovCommand(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BroadcastRegiste) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastRegiste: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastRegiste: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = v
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			m.Ctype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctype |= CommandType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &Request{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Response{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudioData == nil {
				m.AudioData = &AudioData{}
			}
			if err := m.AudioData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &ConnectRequestInfo{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscribe == nil {
				m.Subscribe = &SubscribeTopicRequestInfo{}
			}
			if err := m.Subscribe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectAck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectAck == nil {
				m.ConnectAck = &ConnectResponseInfo{}
			}
			if err := m.ConnectAck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribeAck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscribeAck == nil {
				m.SubscribeAck = &SubscribeTopicResponseInfo{}
			}
			if err := m.SubscribeAck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectRequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Result = v
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeTopicRequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeTopicRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeTopicRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeTopicResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeTopicResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeTopicResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Result = v
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeTopicRequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeTopicRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeTopicRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeTopicResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeTopicResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeTopicResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HoldMicRequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HoldMicRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HoldMicRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HoldMIcResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HoldMIcResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HoldMIcResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseMicRequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseMicRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseMicRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseMicResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseMicResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseMicResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisconnectRequstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisconnectRequstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisconnectRequstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisConnectResponseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisConnectResponseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisConnectResponseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManagerAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManagerAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManagerAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastRegisteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastRegisteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastRegisteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = v
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastRegisteAckInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastRegisteAckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastRegisteAckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = v
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommand(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommand
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCommand
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommand
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommand(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCommand
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommand = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommand   = fmt.Errorf("proto: integer overflow")
)
